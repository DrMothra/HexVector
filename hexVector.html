<!doctype html> 
<html lang="en"> 
<head> 
	<meta charset="UTF-8" />
	<title>Hex Vector</title>
    <script src="js/phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">

var game = new Phaser.Game(800, 600, Phaser.AUTO, '', { preload: preload, create: create });

function preload() {

    game.load.image('vector', 'assets/vectorHex.png');

    game.load.audio('explosion', 'assets/audio/explosion.mp3');
    game.load.audio('sword', 'assets/audio/sword.mp3');
    game.load.audio('blaster', 'assets/audio/blaster.mp3');
    game.load.audio('ping', 'assets/audio/p-ping.mp3');

}

var result;
var musicSquare, musicGroup;
var shapes = [
    {x: 250, y: 110, width: 150, height: 150}
];
var shapeCentres = [
    {x: 300, y: 175, rot: 1.1, scale: 0.225},
    {x: 405, y: 225, rot: -0.63, scale: 0.375},
    {x: 355, y: 350, rot: 1.125, scale: 0.465},
    {x: 250, y: 300, rot: 0, scale: 0.4},
    {x: 355, y: 250, rot: -1.125, scale: 0.475},
    {x: 300, y: 275, rot: 0.375, scale: 0.55}
];
var lineWidth = 3;
var lineColour = 0x868686;
var startX=250, startY=200;
var originYOffset = 100;
var circleSize = 10;
var pyramidLines = [
    {x: 350, y: 150},
    {x: 460, y: 300},
    {x: 250, y:400},
    {x: 250, y: 200},
    {x: 460, y: 300}
];

var notes = ['explosion', 'sword', 'blaster', 'ping'];
var numNotes = 6;
var noteLines = [];
var fx = [];

function create() {

    var i=0;
    var numLines = pyramidLines.length;
    var graphics = game.add.graphics(0, 0);

    // set a line style
    graphics.lineStyle(lineWidth, lineColour, 1);
    graphics.moveTo(startX, startY);
    for(i=0; i<numLines; ++i) {
        graphics.lineTo(pyramidLines[i].x, pyramidLines[i].y);
    }

    graphics.moveTo(pyramidLines[0].x, pyramidLines[0].y);
    graphics.lineTo(pyramidLines[2].x, pyramidLines[2].y);

    graphics.lineStyle(lineWidth, 0xffffff, 1);
    graphics.beginFill(0xffffff);
    for(i=0; i<(numLines-1); ++i) {
        graphics.drawCircle(pyramidLines[i].x, pyramidLines[i].y, circleSize);
    }
    graphics.endFill();

    musicGroup = game.add.group();
    musicGroup.add(graphics);

    musicGroup.getBounds();


    for(i=0; i<numNotes; ++i) {
        noteLines[i] = game.add.sprite(32*(i+1), game.world.height - originYOffset, 'vector');
        noteLines[i].lineNumber = i;
        noteLines[i].anchor.x = 0.5;
        noteLines[i].anchor.y = 0.5;
        noteLines[i].scale.setTo(0.25, 0.25);
        //  Enable input and allow for dragging
        noteLines[i].inputEnabled = true;
        noteLines[i].input.enableDrag();
        noteLines[i].events.onDragStop.add(onDragStop, this);
    }

    for(i=0; i<notes.length; ++i) {
        fx.push(game.add.audio(notes[i]));
    }

    //  Being mp3 files these take time to decode, so we can't play them instantly
    //  Using setDecodedCallback we can be notified when they're ALL ready for use.
    //  The audio files could decode in ANY order, we can never be sure which it'll be.

    //game.sound.setDecodedCallback(fx, start, this);
}

function onDragStop(sprite, pointer) {

    var lineBounds = sprite.getBounds();
    var rectBounds = musicGroup.getBounds();

    console.log("Number =", sprite.lineNumber);

    if(Phaser.Rectangle.intersects(lineBounds, rectBounds)) {
        snapToLine(pointer, sprite.lineNumber);
    } else {
        resetLine(pointer, sprite.lineNumber);
    }

}

function snapToLine(pointer, lineNumber) {

    var minDist = 1000000, centrePoint = undefined;
    var tempDist;
    var tempPoint = new Phaser.Point();
    for(var i=0; i<shapeCentres.length; ++i) {
        tempPoint.setTo(shapeCentres[i].x, shapeCentres[i].y);
        tempDist = Phaser.Point.distance(pointer, tempPoint);
        if(tempDist < minDist) {
            minDist = tempDist;
            centrePoint = i;
        }
    }

    //DEBUG
    //console.log("Centre point = ", centrePoint);
    var line = noteLines[lineNumber];
    if(centrePoint != undefined) {
        line.x = shapeCentres[centrePoint].x;
        line.y = shapeCentres[centrePoint].y;
        line.rotation = shapeCentres[centrePoint].rot;
        line.scale.y = shapeCentres[centrePoint].scale;
        fx[centrePoint].play();
    }
}

function resetLine(pointer, lineNumber) {
    var line = noteLines[lineNumber];

    line.x = 32 * (lineNumber+1);
    line.y = game.world.height - originYOffset;
    line.scale.y = 0.25;
    line.rotation = 0;
}
function checkOverlap(sprite) {
    var bounds = sprite.getBounds();
    var boundsB = musicGroup.getBounds();

    return Phaser.Rectangle.intersects(bounds, boundsB);
}


</script>

</body>
</html>